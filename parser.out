Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    NOTEQUAL
    LOWER
    RETURN
    ARROW
    MODEQ
    READ
    TYPE
    IN
    THEN
    ELSE
    LBRACKET
    SUCC
    PRINT
    FI
    DIV
    NULL
    MINUS
    COMMENT
    LE
    TO
    REF
    BY
    MINUSEQ
    LT
    STRINGCONST
    PLUS
    ARRAY
    DIVEQ
    GT
    END
    RBRACE
    FOR
    TIMESEQ
    PLUSPLUS
    CHARCONST
    PERIOD
    LOC
    GE
    RESULT
    STRCONC
    NUM
    MINUSMINUS
    TIMES
    TRUE
    IF
    AND
    DOWN
    LBRACE
    FALSE
    UPPER
    PLUSEQ
    PRED
    CHARS
    OD
    ELSIF
    SYN
    WHILE
    LENGTH
    RETURNS
    COMMENTLINE
    ISEQUAL
    NOT
    EXIT
    RBRACKET
    PROC
    OR
    MOD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     program -> empty
Rule 3     statement_list -> statement
Rule 4     statement_list -> statement_list statement
Rule 5     statement -> declaration_statement
Rule 6     declaration_statement -> DCL declaration_list SMC
Rule 7     declaration_list -> declaration
Rule 8     declaration_list -> declaration_list COMMA declaration
Rule 9     declaration -> id_list mode initialization
Rule 10    declaration -> id_list mode
Rule 11    id_list -> ID
Rule 12    id_list -> id_list COMMA ID
Rule 13    mode -> mode_name
Rule 14    mode -> discrete_mode
Rule 15    mode_name -> ID
Rule 16    discrete_mode -> basic_mode
Rule 17    discrete_mode -> discrete_range_mode
Rule 18    basic_mode -> INT
Rule 19    basic_mode -> BOOL
Rule 20    basic_mode -> CHAR
Rule 21    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 22    discrete_range_mode -> basic_mode LPAREN literal_range RPAREN
Rule 23    discrete_mode_name -> ID
Rule 24    literal_range -> lower_bound COLON upper_bound
Rule 25    lower_bound -> INTCONST
Rule 26    upper_bound -> INTCONST
Rule 27    initialization -> EQUALS INTCONST
Rule 28    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
ARRAY                : 
ARROW                : 
BOOL                 : 19
BY                   : 
CHAR                 : 20
CHARCONST            : 
CHARS                : 
COLON                : 24
COMMA                : 8 12
COMMENT              : 
COMMENTLINE          : 
DCL                  : 6
DIV                  : 
DIVEQ                : 
DO                   : 
DOWN                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQUALS               : 27
EXIT                 : 
FALSE                : 
FI                   : 
FOR                  : 
GE                   : 
GT                   : 
ID                   : 11 12 15 23
IF                   : 
IN                   : 
INT                  : 18
INTCONST             : 25 26 27
ISEQUAL              : 
LBRACE               : 
LBRACKET             : 
LE                   : 
LENGTH               : 
LOC                  : 
LOWER                : 
LPAREN               : 21 22
LT                   : 
MINUS                : 
MINUSEQ              : 
MINUSMINUS           : 
MOD                  : 
MODEQ                : 
NOT                  : 
NOTEQUAL             : 
NULL                 : 
NUM                  : 
OD                   : 
OR                   : 
PERIOD               : 
PLUS                 : 
PLUSEQ               : 
PLUSPLUS             : 
PRED                 : 
PRINT                : 
PROC                 : 
RBRACE               : 
RBRACKET             : 
READ                 : 
REF                  : 
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 21 22
SMC                  : 6
STRCONC              : 
STRINGCONST          : 
SUCC                 : 
SYN                  : 
THEN                 : 
TIMES                : 
TIMESEQ              : 
TO                   : 
TRUE                 : 
TYPE                 : 
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

basic_mode           : 16 22
declaration          : 7 8
declaration_list     : 6 8
declaration_statement : 5
discrete_mode        : 14
discrete_mode_name   : 21
discrete_range_mode  : 17
empty                : 2
id_list              : 9 10 12
initialization       : 9
literal_range        : 21 22
lower_bound          : 24
mode                 : 9 10
mode_name            : 13
program              : 0
statement            : 3 4
statement_list       : 1 4
upper_bound          : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) program -> . empty
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (28) empty -> .
    (5) statement -> . declaration_statement
    (6) declaration_statement -> . DCL declaration_list SMC

    $end            reduce using rule 28 (empty -> .)
    DCL             shift and go to state 1

    program                        shift and go to state 2
    statement                      shift and go to state 3
    declaration_statement          shift and go to state 4
    statement_list                 shift and go to state 5
    empty                          shift and go to state 6

state 1

    (6) declaration_statement -> DCL . declaration_list SMC
    (7) declaration_list -> . declaration
    (8) declaration_list -> . declaration_list COMMA declaration
    (9) declaration -> . id_list mode initialization
    (10) declaration -> . id_list mode
    (11) id_list -> . ID
    (12) id_list -> . id_list COMMA ID

    ID              shift and go to state 10

    id_list                        shift and go to state 8
    declaration                    shift and go to state 9
    declaration_list               shift and go to state 7

state 2

    (0) S' -> program .



state 3

    (3) statement_list -> statement .

    DCL             reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)


state 4

    (5) statement -> declaration_statement .

    DCL             reduce using rule 5 (statement -> declaration_statement .)
    $end            reduce using rule 5 (statement -> declaration_statement .)


state 5

    (1) program -> statement_list .
    (4) statement_list -> statement_list . statement
    (5) statement -> . declaration_statement
    (6) declaration_statement -> . DCL declaration_list SMC

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 1

    declaration_statement          shift and go to state 4
    statement                      shift and go to state 11

state 6

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 7

    (6) declaration_statement -> DCL declaration_list . SMC
    (8) declaration_list -> declaration_list . COMMA declaration

    SMC             shift and go to state 13
    COMMA           shift and go to state 12


state 8

    (9) declaration -> id_list . mode initialization
    (10) declaration -> id_list . mode
    (12) id_list -> id_list . COMMA ID
    (13) mode -> . mode_name
    (14) mode -> . discrete_mode
    (15) mode_name -> . ID
    (16) discrete_mode -> . basic_mode
    (17) discrete_mode -> . discrete_range_mode
    (18) basic_mode -> . INT
    (19) basic_mode -> . BOOL
    (20) basic_mode -> . CHAR
    (21) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (22) discrete_range_mode -> . basic_mode LPAREN literal_range RPAREN
    (23) discrete_mode_name -> . ID

    COMMA           shift and go to state 18
    ID              shift and go to state 24
    INT             shift and go to state 22
    BOOL            shift and go to state 21
    CHAR            shift and go to state 16

    basic_mode                     shift and go to state 14
    discrete_range_mode            shift and go to state 15
    discrete_mode_name             shift and go to state 17
    mode                           shift and go to state 19
    discrete_mode                  shift and go to state 20
    mode_name                      shift and go to state 23

state 9

    (7) declaration_list -> declaration .

    SMC             reduce using rule 7 (declaration_list -> declaration .)
    COMMA           reduce using rule 7 (declaration_list -> declaration .)


state 10

    (11) id_list -> ID .

    COMMA           reduce using rule 11 (id_list -> ID .)
    ID              reduce using rule 11 (id_list -> ID .)
    INT             reduce using rule 11 (id_list -> ID .)
    BOOL            reduce using rule 11 (id_list -> ID .)
    CHAR            reduce using rule 11 (id_list -> ID .)


state 11

    (4) statement_list -> statement_list statement .

    DCL             reduce using rule 4 (statement_list -> statement_list statement .)
    $end            reduce using rule 4 (statement_list -> statement_list statement .)


state 12

    (8) declaration_list -> declaration_list COMMA . declaration
    (9) declaration -> . id_list mode initialization
    (10) declaration -> . id_list mode
    (11) id_list -> . ID
    (12) id_list -> . id_list COMMA ID

    ID              shift and go to state 10

    id_list                        shift and go to state 8
    declaration                    shift and go to state 25

state 13

    (6) declaration_statement -> DCL declaration_list SMC .

    DCL             reduce using rule 6 (declaration_statement -> DCL declaration_list SMC .)
    $end            reduce using rule 6 (declaration_statement -> DCL declaration_list SMC .)


state 14

    (16) discrete_mode -> basic_mode .
    (22) discrete_range_mode -> basic_mode . LPAREN literal_range RPAREN

    EQUALS          reduce using rule 16 (discrete_mode -> basic_mode .)
    SMC             reduce using rule 16 (discrete_mode -> basic_mode .)
    COMMA           reduce using rule 16 (discrete_mode -> basic_mode .)
    LPAREN          shift and go to state 26


state 15

    (17) discrete_mode -> discrete_range_mode .

    EQUALS          reduce using rule 17 (discrete_mode -> discrete_range_mode .)
    SMC             reduce using rule 17 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 17 (discrete_mode -> discrete_range_mode .)


state 16

    (20) basic_mode -> CHAR .

    LPAREN          reduce using rule 20 (basic_mode -> CHAR .)
    EQUALS          reduce using rule 20 (basic_mode -> CHAR .)
    SMC             reduce using rule 20 (basic_mode -> CHAR .)
    COMMA           reduce using rule 20 (basic_mode -> CHAR .)


state 17

    (21) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 27


state 18

    (12) id_list -> id_list COMMA . ID

    ID              shift and go to state 28


state 19

    (9) declaration -> id_list mode . initialization
    (10) declaration -> id_list mode .
    (27) initialization -> . EQUALS INTCONST

    SMC             reduce using rule 10 (declaration -> id_list mode .)
    COMMA           reduce using rule 10 (declaration -> id_list mode .)
    EQUALS          shift and go to state 30

    initialization                 shift and go to state 29

state 20

    (14) mode -> discrete_mode .

    EQUALS          reduce using rule 14 (mode -> discrete_mode .)
    SMC             reduce using rule 14 (mode -> discrete_mode .)
    COMMA           reduce using rule 14 (mode -> discrete_mode .)


state 21

    (19) basic_mode -> BOOL .

    LPAREN          reduce using rule 19 (basic_mode -> BOOL .)
    EQUALS          reduce using rule 19 (basic_mode -> BOOL .)
    SMC             reduce using rule 19 (basic_mode -> BOOL .)
    COMMA           reduce using rule 19 (basic_mode -> BOOL .)


state 22

    (18) basic_mode -> INT .

    LPAREN          reduce using rule 18 (basic_mode -> INT .)
    EQUALS          reduce using rule 18 (basic_mode -> INT .)
    SMC             reduce using rule 18 (basic_mode -> INT .)
    COMMA           reduce using rule 18 (basic_mode -> INT .)


state 23

    (13) mode -> mode_name .

    EQUALS          reduce using rule 13 (mode -> mode_name .)
    SMC             reduce using rule 13 (mode -> mode_name .)
    COMMA           reduce using rule 13 (mode -> mode_name .)


state 24

    (15) mode_name -> ID .
    (23) discrete_mode_name -> ID .

    EQUALS          reduce using rule 15 (mode_name -> ID .)
    SMC             reduce using rule 15 (mode_name -> ID .)
    COMMA           reduce using rule 15 (mode_name -> ID .)
    LPAREN          reduce using rule 23 (discrete_mode_name -> ID .)


state 25

    (8) declaration_list -> declaration_list COMMA declaration .

    SMC             reduce using rule 8 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 8 (declaration_list -> declaration_list COMMA declaration .)


state 26

    (22) discrete_range_mode -> basic_mode LPAREN . literal_range RPAREN
    (24) literal_range -> . lower_bound COLON upper_bound
    (25) lower_bound -> . INTCONST

    INTCONST        shift and go to state 32

    lower_bound                    shift and go to state 31
    literal_range                  shift and go to state 33

state 27

    (21) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (24) literal_range -> . lower_bound COLON upper_bound
    (25) lower_bound -> . INTCONST

    INTCONST        shift and go to state 32

    lower_bound                    shift and go to state 31
    literal_range                  shift and go to state 34

state 28

    (12) id_list -> id_list COMMA ID .

    COMMA           reduce using rule 12 (id_list -> id_list COMMA ID .)
    ID              reduce using rule 12 (id_list -> id_list COMMA ID .)
    INT             reduce using rule 12 (id_list -> id_list COMMA ID .)
    BOOL            reduce using rule 12 (id_list -> id_list COMMA ID .)
    CHAR            reduce using rule 12 (id_list -> id_list COMMA ID .)


state 29

    (9) declaration -> id_list mode initialization .

    SMC             reduce using rule 9 (declaration -> id_list mode initialization .)
    COMMA           reduce using rule 9 (declaration -> id_list mode initialization .)


state 30

    (27) initialization -> EQUALS . INTCONST

    INTCONST        shift and go to state 35


state 31

    (24) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 36


state 32

    (25) lower_bound -> INTCONST .

    COLON           reduce using rule 25 (lower_bound -> INTCONST .)


state 33

    (22) discrete_range_mode -> basic_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 37


state 34

    (21) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 38


state 35

    (27) initialization -> EQUALS INTCONST .

    SMC             reduce using rule 27 (initialization -> EQUALS INTCONST .)
    COMMA           reduce using rule 27 (initialization -> EQUALS INTCONST .)


state 36

    (24) literal_range -> lower_bound COLON . upper_bound
    (26) upper_bound -> . INTCONST

    INTCONST        shift and go to state 39

    upper_bound                    shift and go to state 40

state 37

    (22) discrete_range_mode -> basic_mode LPAREN literal_range RPAREN .

    EQUALS          reduce using rule 22 (discrete_range_mode -> basic_mode LPAREN literal_range RPAREN .)
    SMC             reduce using rule 22 (discrete_range_mode -> basic_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 22 (discrete_range_mode -> basic_mode LPAREN literal_range RPAREN .)


state 38

    (21) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    EQUALS          reduce using rule 21 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SMC             reduce using rule 21 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 21 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 39

    (26) upper_bound -> INTCONST .

    RPAREN          reduce using rule 26 (upper_bound -> INTCONST .)


state 40

    (24) literal_range -> lower_bound COLON upper_bound .

    RPAREN          reduce using rule 24 (literal_range -> lower_bound COLON upper_bound .)

